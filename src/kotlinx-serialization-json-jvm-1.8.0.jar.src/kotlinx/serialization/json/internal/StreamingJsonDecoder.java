/*     */ package kotlinx.serialization.json.internal;
/*     */ @Metadata(mv = {2, 1, 0}, k = 1, xi = 48, d1 = {"\000º\001\n\002\030\002\n\002\030\002\n\002\030\002\n\002\030\002\n\000\n\002\030\002\n\000\n\002\030\002\n\000\n\002\030\002\n\000\n\002\030\002\n\000\n\002\030\002\n\002\b\005\n\002\020\013\n\000\n\002\020\016\n\000\n\002\030\002\n\002\b\003\n\002\020\b\n\000\n\002\030\002\n\000\n\002\030\002\n\000\n\002\030\002\n\002\b\003\n\002\030\002\n\002\b\002\n\002\030\002\n\000\n\002\020\002\n\002\b\003\n\002\020\001\n\002\b\016\n\002\020\005\n\000\n\002\020\n\n\002\b\002\n\002\020\t\n\000\n\002\020\007\n\000\n\002\020\006\n\000\n\002\020\f\n\002\b\004\n\002\030\002\n\002\030\002\n\002\b\003\n\002\030\002\n\002\b\004\b\020\030\0002\0020\0012\0020\0022\0020\003:\001UB1\022\006\020\004\032\0020\005\022\006\020\006\032\0020\007\022\006\020\b\032\0020\t\022\006\020\n\032\0020\013\022\b\020\f\032\004\030\0010\r¢\006\004\b\016\020\017J\026\020\022\032\0020\023*\004\030\0010\r2\006\020\024\032\0020\025H\002J\b\020 \032\0020!H\026J!\020\"\032\002H#\"\004\b\000\020#2\f\020$\032\b\022\004\022\002H#0%H\026¢\006\002\020&J\020\020'\032\0020(2\006\020\n\032\0020\013H\026J\020\020)\032\0020*2\006\020\n\032\0020\013H\026J\020\020+\032\0020*2\006\020\n\032\0020\013H\002J\b\020,\032\0020\023H\026J\n\020-\032\004\030\0010.H\026J\b\020/\032\0020*H\002J;\0200\032\002H#\"\004\b\000\020#2\006\020\n\032\0020\0132\006\0201\032\0020\0332\f\020$\032\b\022\004\022\002H#0%2\b\0202\032\004\030\001H#H\026¢\006\002\0203J\020\0204\032\0020\0332\006\020\n\032\0020\013H\026J\b\0205\032\0020\033H\002J\030\0206\032\0020\0232\006\020\n\032\0020\0132\006\0201\032\0020\033H\002J\020\0207\032\0020\0332\006\020\n\032\0020\013H\002J\030\0208\032\0020\0232\006\020\n\032\0020\0132\006\0209\032\0020\025H\002J\b\020:\032\0020\033H\002J\b\020;\032\0020\023H\026J\b\020<\032\0020=H\026J\b\020>\032\0020?H\026J\b\020@\032\0020\033H\026J\b\020A\032\0020BH\026J\b\020C\032\0020DH\026J\b\020E\032\0020FH\026J\b\020G\032\0020HH\026J\b\020I\032\0020\025H\002J\b\020J\032\0020\025H\026J+\020K\032\0020*2!\020L\032\035\022\023\022\0210\025¢\006\f\bN\022\b\bO\022\004\b\b(P\022\004\022\0020*0MH\026J\020\020Q\032\0020R2\006\020\n\032\0020\013H\026J\020\020S\032\0020\0332\006\020T\032\0020\013H\026R\021\020\004\032\0020\005¢\006\b\n\000\032\004\b\020\020\021R\016\020\006\032\0020\007X\004¢\006\002\n\000R\020\020\b\032\0020\t8\000X\004¢\006\002\n\000R\024\020\026\032\0020\027X\004¢\006\b\n\000\032\004\b\030\020\031R\016\020\032\032\0020\033X\016¢\006\002\n\000R\020\020\f\032\004\030\0010\rX\016¢\006\002\n\000R\016\020\034\032\0020\035X\004¢\006\002\n\000R\020\020\036\032\004\030\0010\037X\004¢\006\002\n\000¨\006V"}, d2 = {"Lkotlinx/serialization/json/internal/StreamingJsonDecoder;", "Lkotlinx/serialization/json/JsonDecoder;", "Lkotlinx/serialization/encoding/ChunkedDecoder;", "Lkotlinx/serialization/encoding/AbstractDecoder;", "json", "Lkotlinx/serialization/json/Json;", "mode", "Lkotlinx/serialization/json/internal/WriteMode;", "lexer", "Lkotlinx/serialization/json/internal/AbstractJsonLexer;", "descriptor", "Lkotlinx/serialization/descriptors/SerialDescriptor;", "discriminatorHolder", "Lkotlinx/serialization/json/internal/StreamingJsonDecoder$DiscriminatorHolder;", "<init>", "(Lkotlinx/serialization/json/Json;Lkotlinx/serialization/json/internal/WriteMode;Lkotlinx/serialization/json/internal/AbstractJsonLexer;Lkotlinx/serialization/descriptors/SerialDescriptor;Lkotlinx/serialization/json/internal/StreamingJsonDecoder$DiscriminatorHolder;)V", "getJson", "()Lkotlinx/serialization/json/Json;", "trySkip", "", "unknownKey", "", "serializersModule", "Lkotlinx/serialization/modules/SerializersModule;", "getSerializersModule", "()Lkotlinx/serialization/modules/SerializersModule;", "currentIndex", "", "configuration", "Lkotlinx/serialization/json/JsonConfiguration;", "elementMarker", "Lkotlinx/serialization/json/internal/JsonElementMarker;", "decodeJsonElement", "Lkotlinx/serialization/json/JsonElement;", "decodeSerializableValue", "T", "deserializer", "Lkotlinx/serialization/DeserializationStrategy;", "(Lkotlinx/serialization/DeserializationStrategy;)Ljava/lang/Object;", "beginStructure", "Lkotlinx/serialization/encoding/CompositeDecoder;", "endStructure", "", "skipLeftoverElements", "decodeNotNullMark", "decodeNull", "", "checkLeadingComma", "decodeSerializableElement", "index", "previousValue", "(Lkotlinx/serialization/descriptors/SerialDescriptor;ILkotlinx/serialization/DeserializationStrategy;Ljava/lang/Object;)Ljava/lang/Object;", "decodeElementIndex", "decodeMapIndex", "coerceInputValue", "decodeObjectIndex", "handleUnknown", "key", "decodeListIndex", "decodeBoolean", "decodeByte", "", "decodeShort", "", "decodeInt", "decodeLong", "", "decodeFloat", "", "decodeDouble", "", "decodeChar", "", "decodeStringKey", "decodeString", "decodeStringChunked", "consumeChunk", "Lkotlin/Function1;", "Lkotlin/ParameterName;", "name", "chunk", "decodeInline", "Lkotlinx/serialization/encoding/Decoder;", "decodeEnum", "enumDescriptor", "DiscriminatorHolder", "kotlinx-serialization-json"})
/*     */ @SourceDebugExtension({"SMAP\nStreamingJsonDecoder.kt\nKotlin\n*S Kotlin\n*F\n+ 1 StreamingJsonDecoder.kt\nkotlinx/serialization/json/internal/StreamingJsonDecoder\n+ 2 Polymorphic.kt\nkotlinx/serialization/json/internal/PolymorphicKt\n+ 3 TreeJsonEncoder.kt\nkotlinx/serialization/json/internal/TreeJsonEncoderKt\n+ 4 AbstractJsonLexer.kt\nkotlinx/serialization/json/internal/AbstractJsonLexer\n+ 5 JsonNamesMap.kt\nkotlinx/serialization/json/internal/JsonNamesMapKt\n+ 6 StreamingJsonDecoder.kt\nkotlinx/serialization/json/internal/StreamingJsonDecoderKt\n*L\n1#1,392:1\n78#2,6:393\n84#2,9:407\n270#3,8:399\n517#4,3:416\n517#4,3:419\n133#5,18:422\n385#6,5:440\n385#6,5:445\n*S KotlinDebug\n*F\n+ 1 StreamingJsonDecoder.kt\nkotlinx/serialization/json/internal/StreamingJsonDecoder\n*L\n75#1:393,6\n75#1:407,9\n75#1:399,8\n202#1:416,3\n203#1:419,3\n215#1:422,18\n309#1:440,5\n316#1:445,5\n*E\n"})
/*     */ public class StreamingJsonDecoder extends AbstractDecoder implements JsonDecoder, ChunkedDecoder { @NotNull
/*     */   private final Json json;
/*     */   @NotNull
/*     */   private final WriteMode mode;
/*     */   @JvmField
/*     */   @NotNull
/*     */   public final AbstractJsonLexer lexer;
/*     */   @NotNull
/*     */   private final SerializersModule serializersModule;
/*     */   private int currentIndex;
/*     */   @Nullable
/*     */   private DiscriminatorHolder discriminatorHolder;
/*     */   @NotNull
/*     */   private final JsonConfiguration configuration;
/*     */   @Nullable
/*     */   private final JsonElementMarker elementMarker;
/*     */   
/*     */   @NotNull
/*  22 */   public final Json getJson() { return this.json; } public StreamingJsonDecoder(@NotNull Json json, @NotNull WriteMode mode, @NotNull AbstractJsonLexer lexer, @NotNull SerialDescriptor descriptor, @Nullable DiscriminatorHolder discriminatorHolder) { this.json = json;
/*  23 */     this.mode = mode;
/*  24 */     this.lexer = lexer;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*  43 */     this.serializersModule = this.json.getSerializersModule();
/*  44 */     this.currentIndex = -1;
/*  45 */     this.discriminatorHolder = discriminatorHolder;
/*  46 */     this.configuration = this.json.getConfiguration();
/*     */     
/*  48 */     this.elementMarker = this.configuration.getExplicitNulls() ? null : new JsonElementMarker(descriptor); } @Metadata(mv = {2, 1, 0}, k = 1, xi = 48, d1 = {"\000\022\n\002\030\002\n\002\020\000\n\000\n\002\020\016\n\002\b\003\b\000\030\0002\0020\001B\021\022\b\020\002\032\004\030\0010\003¢\006\004\b\004\020\005R\024\020\002\032\004\030\0010\0038\006@\006X\016¢\006\002\n\000¨\006\006"}, d2 = {"Lkotlinx/serialization/json/internal/StreamingJsonDecoder$DiscriminatorHolder;", "", "discriminatorToSkip", "", "<init>", "(Ljava/lang/String;)V", "kotlinx-serialization-json"}) public static final class DiscriminatorHolder {
/*     */     @JvmField @Nullable public String discriminatorToSkip; public DiscriminatorHolder(@Nullable String discriminatorToSkip) { this.discriminatorToSkip = discriminatorToSkip; } } private final boolean trySkip(DiscriminatorHolder $this$trySkip, String unknownKey) { if ($this$trySkip == null) return false;  if (Intrinsics.areEqual($this$trySkip.discriminatorToSkip, unknownKey)) { $this$trySkip.discriminatorToSkip = null; return true; }  return false; } @NotNull public SerializersModule getSerializersModule() { return this.serializersModule; }
/*  50 */   @NotNull public JsonElement decodeJsonElement() { return (new JsonTreeReader(this.json.getConfiguration(), this.lexer)).read(); }
/*     */   @NotNull public CompositeDecoder beginStructure(@NotNull SerialDescriptor descriptor) { Intrinsics.checkNotNullParameter(descriptor, "descriptor"); WriteMode newMode = WriteModeKt.switchMode(this.json, descriptor); this.lexer.path.pushDescriptor(descriptor); this.lexer.consumeNextToken(newMode.begin); checkLeadingComma(); switch (WhenMappings.$EnumSwitchMapping$0[newMode.ordinal()]) { case 1: case 2: case 3:  }  return (this.mode == newMode && this.json.getConfiguration().getExplicitNulls()) ? (CompositeDecoder)this : (CompositeDecoder)new StreamingJsonDecoder(this.json, newMode, this.lexer, descriptor, this.discriminatorHolder); }
/*     */   public void endStructure(@NotNull SerialDescriptor descriptor) { Intrinsics.checkNotNullParameter(descriptor, "descriptor"); if (descriptor.getElementsCount() == 0 && JsonNamesMapKt.ignoreUnknownKeys(descriptor, this.json)) skipLeftoverElements(descriptor);  if (this.lexer.tryConsumeComma() && !this.json.getConfiguration().getAllowTrailingComma()) { JsonExceptionsKt.invalidTrailingComma(this.lexer, ""); throw new KotlinNothingValueException(); }  this.lexer.consumeNextToken(this.mode.end); this.lexer.path.popDescriptor(); }
/*  53 */   private final void skipLeftoverElements(SerialDescriptor descriptor) { do {  } while (decodeElementIndex(descriptor) != -1); } public boolean decodeNotNullMark() { return (!((this.elementMarker != null) ? this.elementMarker.isUnmarkedNull$kotlinx_serialization_json() : 0) && !AbstractJsonLexer.tryConsumeNull$default(this.lexer, false, 1, null)); } public <T> T decodeSerializableValue(@NotNull DeserializationStrategy deserializer) { Intrinsics.checkNotNullParameter(deserializer, "deserializer");
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*     */     try { String type;
/*     */ 
/*     */ 
/*     */ 
/*     */       
/*     */       DeserializationStrategy deserializationStrategy2;
/*     */ 
/*     */ 
/*     */       
/*  68 */       if (!(deserializer instanceof AbstractPolymorphicSerializer) || this.json.getConfiguration().getUseArrayPolymorphism()) {
/*  69 */         return (T)deserializer.deserialize((Decoder)this);
/*     */       }
/*     */       
/*  72 */       String discriminator = PolymorphicKt.classDiscriminator(((AbstractPolymorphicSerializer)deserializer).getDescriptor(), this.json);
/*  73 */       if (this.lexer.peekLeadingMatchingValue(discriminator, this.configuration.isLenient()) == null) { DeserializationStrategy<? extends T> deserializationStrategy4; this.lexer.peekLeadingMatchingValue(discriminator, this.configuration.isLenient());
/*     */         
/*  75 */         StreamingJsonDecoder streamingJsonDecoder = this; deserializationStrategy2 = deserializer; int $i$f$decodeSerializableValuePolymorphic = 0;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */         
/* 396 */         String discriminator$iv = PolymorphicKt.classDiscriminator(((AbstractPolymorphicSerializer)deserializationStrategy2).getDescriptor(), streamingJsonDecoder.getJson());
/*     */         
/* 398 */         JsonElement jsonElement = streamingJsonDecoder.decodeJsonElement(); String serialName$iv$iv = ((AbstractPolymorphicSerializer)deserializationStrategy2).getDescriptor().getSerialName(); int $i$f$cast = 0;
/* 399 */         if (!(jsonElement instanceof JsonObject)) {
/*     */ 
/*     */           
/* 402 */           StringBuilder stringBuilder = (new StringBuilder()).append("Expected ").append(Reflection.getOrCreateKotlinClass(JsonObject.class).getSimpleName()).append(", but had ").append(Reflection.getOrCreateKotlinClass(jsonElement.getClass()).getSimpleName()).append(" as the serialized body of ").append(serialName$iv$iv).append(" at element: "); byte b = -1; int $i$a$-decodeSerializableValuePolymorphic-StreamingJsonDecoder$decodeSerializableValue$type$1 = 0;
/*     */           
/*     */           String str = this.lexer.path.getPath();
/*     */         } 
/* 406 */         JsonObject jsonTree$iv = (JsonObject)jsonElement;
/* 407 */         JsonElementKt.getJsonPrimitive((JsonElement)jsonTree$iv.get(discriminator$iv)); String type$iv = ((JsonElement)jsonTree$iv.get(discriminator$iv) != null && JsonElementKt.getJsonPrimitive((JsonElement)jsonTree$iv.get(discriminator$iv)) != null) ? JsonElementKt.getContentOrNull(JsonElementKt.getJsonPrimitive((JsonElement)jsonTree$iv.get(discriminator$iv))) : null;
/*     */ 
/*     */         
/*     */         try {
/* 411 */           deserializationStrategy4 = PolymorphicSerializerKt.findPolymorphicSerializer((AbstractPolymorphicSerializer)deserializationStrategy2, (CompositeDecoder)streamingJsonDecoder, type$iv);
/* 412 */         } catch (SerializationException it$iv) {
/* 413 */           Intrinsics.checkNotNull(it$iv.getMessage()); throw JsonExceptionsKt.JsonDecodingException(-1, it$iv.getMessage(), (CharSequence)jsonTree$iv.toString());
/*     */         }  DeserializationStrategy<? extends T> deserializationStrategy3 = deserializationStrategy4; Intrinsics.checkNotNull(deserializationStrategy3, "null cannot be cast to non-null type kotlinx.serialization.DeserializationStrategy<T of kotlinx.serialization.json.internal.PolymorphicKt.decodeSerializableValuePolymorphic>"); DeserializationStrategy<? extends T> actualSerializer$iv = deserializationStrategy3;
/* 415 */         return (!(deserializationStrategy2 instanceof AbstractPolymorphicSerializer) || streamingJsonDecoder.getJson().getConfiguration().getUseArrayPolymorphism()) ? (T)deserializationStrategy2.deserialize((Decoder)streamingJsonDecoder) : TreeJsonDecoderKt.<T>readPolymorphicJson(streamingJsonDecoder.getJson(), discriminator$iv, jsonTree$iv, actualSerializer$iv); }  try { deserializationStrategy2 = PolymorphicSerializerKt.findPolymorphicSerializer((AbstractPolymorphicSerializer)deserializer, (CompositeDecoder)this, type); } catch (SerializationException it) { Intrinsics.checkNotNull(it.getMessage()); String message = StringsKt.removeSuffix(StringsKt.substringBefore$default(it.getMessage(), '\n', null, 2, null), "."); Intrinsics.checkNotNull(it.getMessage()); String hint = StringsKt.substringAfter(it.getMessage(), '\n', ""); AbstractJsonLexer.fail$default(this.lexer, message, 0, hint, 2, null); throw new KotlinNothingValueException(); }  DeserializationStrategy deserializationStrategy1 = deserializationStrategy2; Intrinsics.checkNotNull(deserializationStrategy1, "null cannot be cast to non-null type kotlinx.serialization.DeserializationStrategy<T of kotlinx.serialization.json.internal.StreamingJsonDecoder.decodeSerializableValue>"); DeserializationStrategy actualSerializer = deserializationStrategy1; this.discriminatorHolder = new DiscriminatorHolder(discriminator); return (T)actualSerializer.deserialize((Decoder)this); } catch (MissingFieldException e) { Intrinsics.checkNotNull(e.getMessage()); if (StringsKt.contains$default(e.getMessage(), "at path", false, 2, null)) throw e;  throw new MissingFieldException(e.getMissingFields(), e.getMessage() + " at path: " + this.lexer.path.getPath(), (Throwable)e); }  }
/* 416 */   @Nullable public Void decodeNull() { return null; } private final void checkLeadingComma() { if (this.lexer.peekNextToken() == 4) { AbstractJsonLexer.fail$default(this.lexer, "Unexpected leading comma", 0, null, 6, null); throw new KotlinNothingValueException(); }  } public <T> T decodeSerializableElement(@NotNull SerialDescriptor descriptor, int index, @NotNull DeserializationStrategy deserializer, @Nullable Object previousValue) { Intrinsics.checkNotNullParameter(descriptor, "descriptor"); Intrinsics.checkNotNullParameter(deserializer, "deserializer"); boolean isMapKey = (this.mode == WriteMode.MAP && (index & 0x1) == 0); if (isMapKey) this.lexer.path.resetCurrentMapKey();  Object value = super.decodeSerializableElement(descriptor, index, deserializer, previousValue); if (isMapKey) this.lexer.path.updateCurrentMapKey(value);  return (T)value; } public int decodeElementIndex(@NotNull SerialDescriptor descriptor) { Intrinsics.checkNotNullParameter(descriptor, "descriptor"); switch (WhenMappings.$EnumSwitchMapping$0[this.mode.ordinal()]) { case 4: case 2: default: break; }  int index = decodeListIndex(); if (this.mode != WriteMode.MAP) this.lexer.path.updateDescriptorIndex(index);  return index; } private final int decodeMapIndex() { boolean hasComma = false; boolean decodingKey = (this.currentIndex % 2 != 0); if (decodingKey) { if (this.currentIndex != -1) hasComma = this.lexer.tryConsumeComma();  } else { this.lexer.consumeNextToken(':'); }  if (decodingKey) { AbstractJsonLexer abstractJsonLexer1 = this.lexer; boolean condition$iv = !hasComma; int i = abstractJsonLexer1.currentPosition, j = 0;
/* 417 */       if (!condition$iv) { AbstractJsonLexer abstractJsonLexer = abstractJsonLexer1; int $i$a$-require$kotlinx_serialization_json$default-StreamingJsonDecoder$decodeMapIndex$1 = 0; AbstractJsonLexer.fail$default(abstractJsonLexer, "Unexpected leading comma", i, null, 4, null); throw new KotlinNothingValueException(); }
/*     */        AbstractJsonLexer $this$iv = this.lexer;
/* 419 */       int position$iv = $this$iv.currentPosition, $i$f$require$kotlinx_serialization_json = 0;
/* 420 */       if (!hasComma) { AbstractJsonLexer abstractJsonLexer = $this$iv; int $i$a$-require$kotlinx_serialization_json$default-StreamingJsonDecoder$decodeMapIndex$2 = 0; AbstractJsonLexer.fail$default(abstractJsonLexer, "Expected comma after the key-value pair", position$iv, null, 4, null); throw new KotlinNothingValueException(); }  }  this.currentIndex++; if (hasComma && !this.json.getConfiguration().getAllowTrailingComma()) { JsonExceptionsKt.invalidTrailingComma$default(this.lexer, null, 1, null); throw new KotlinNothingValueException(); }  return this.lexer.canConsumeValue() ? this.currentIndex : -1; } private final boolean coerceInputValue(SerialDescriptor descriptor, int index) { // Byte code:
/*     */     //   0: aload_0
/*     */     //   1: getfield json : Lkotlinx/serialization/json/Json;
/*     */     //   4: astore_3
/*     */     //   5: iconst_0
/*     */     //   6: istore #4
/*     */     //   8: aload_1
/*     */     //   9: iload_2
/*     */     //   10: invokeinterface isElementOptional : (I)Z
/*     */     //   15: istore #5
/*     */     //   17: aload_1
/*     */     //   18: iload_2
/*     */     //   19: invokeinterface getElementDescriptor : (I)Lkotlinx/serialization/descriptors/SerialDescriptor;
/*     */     //   24: astore #6
/*     */     //   26: iload #5
/*     */     //   28: ifeq -> 63
/*     */     //   31: aload #6
/*     */     //   33: invokeinterface isNullable : ()Z
/*     */     //   38: ifne -> 63
/*     */     //   41: iconst_1
/*     */     //   42: istore #7
/*     */     //   44: iconst_0
/*     */     //   45: istore #8
/*     */     //   47: aload_0
/*     */     //   48: getfield lexer : Lkotlinx/serialization/json/internal/AbstractJsonLexer;
/*     */     //   51: iload #7
/*     */     //   53: invokevirtual tryConsumeNull : (Z)Z
/*     */     //   56: ifeq -> 63
/*     */     //   59: iconst_1
/*     */     //   60: goto -> 210
/*     */     //   63: aload #6
/*     */     //   65: invokeinterface getKind : ()Lkotlinx/serialization/descriptors/SerialKind;
/*     */     //   70: getstatic kotlinx/serialization/descriptors/SerialKind$ENUM.INSTANCE : Lkotlinx/serialization/descriptors/SerialKind$ENUM;
/*     */     //   73: invokestatic areEqual : (Ljava/lang/Object;Ljava/lang/Object;)Z
/*     */     //   76: ifeq -> 209
/*     */     //   79: aload #6
/*     */     //   81: invokeinterface isNullable : ()Z
/*     */     //   86: ifeq -> 111
/*     */     //   89: iconst_0
/*     */     //   90: istore #7
/*     */     //   92: iconst_0
/*     */     //   93: istore #8
/*     */     //   95: aload_0
/*     */     //   96: getfield lexer : Lkotlinx/serialization/json/internal/AbstractJsonLexer;
/*     */     //   99: iload #7
/*     */     //   101: invokevirtual tryConsumeNull : (Z)Z
/*     */     //   104: ifeq -> 111
/*     */     //   107: iconst_0
/*     */     //   108: goto -> 210
/*     */     //   111: iconst_0
/*     */     //   112: istore #7
/*     */     //   114: aload_0
/*     */     //   115: getfield lexer : Lkotlinx/serialization/json/internal/AbstractJsonLexer;
/*     */     //   118: aload_0
/*     */     //   119: getfield configuration : Lkotlinx/serialization/json/JsonConfiguration;
/*     */     //   122: invokevirtual isLenient : ()Z
/*     */     //   125: invokevirtual peekString : (Z)Ljava/lang/String;
/*     */     //   128: dup
/*     */     //   129: ifnonnull -> 137
/*     */     //   132: pop
/*     */     //   133: iconst_0
/*     */     //   134: goto -> 210
/*     */     //   137: astore #9
/*     */     //   139: aload #6
/*     */     //   141: aload_3
/*     */     //   142: aload #9
/*     */     //   144: invokestatic getJsonNameIndex : (Lkotlinx/serialization/descriptors/SerialDescriptor;Lkotlinx/serialization/json/Json;Ljava/lang/String;)I
/*     */     //   147: istore #7
/*     */     //   149: aload_3
/*     */     //   150: invokevirtual getConfiguration : ()Lkotlinx/serialization/json/JsonConfiguration;
/*     */     //   153: invokevirtual getExplicitNulls : ()Z
/*     */     //   156: ifne -> 173
/*     */     //   159: aload #6
/*     */     //   161: invokeinterface isNullable : ()Z
/*     */     //   166: ifeq -> 173
/*     */     //   169: iconst_1
/*     */     //   170: goto -> 174
/*     */     //   173: iconst_0
/*     */     //   174: istore #8
/*     */     //   176: iload #7
/*     */     //   178: bipush #-3
/*     */     //   180: if_icmpne -> 209
/*     */     //   183: iload #5
/*     */     //   185: ifne -> 193
/*     */     //   188: iload #8
/*     */     //   190: ifeq -> 209
/*     */     //   193: iconst_0
/*     */     //   194: istore #10
/*     */     //   196: aload_0
/*     */     //   197: getfield lexer : Lkotlinx/serialization/json/internal/AbstractJsonLexer;
/*     */     //   200: invokevirtual consumeString : ()Ljava/lang/String;
/*     */     //   203: pop
/*     */     //   204: nop
/*     */     //   205: iconst_1
/*     */     //   206: goto -> 210
/*     */     //   209: iconst_0
/*     */     //   210: ireturn
/*     */     // Line number table:
/*     */     //   Java source line number -> byte code offset
/*     */     //   #215	-> 0
/*     */     //   #422	-> 8
/*     */     //   #423	-> 17
/*     */     //   #424	-> 26
/*     */     //   #217	-> 47
/*     */     //   #424	-> 56
/*     */     //   #425	-> 63
/*     */     //   #426	-> 79
/*     */     //   #217	-> 95
/*     */     //   #426	-> 104
/*     */     //   #427	-> 107
/*     */     //   #430	-> 111
/*     */     //   #218	-> 114
/*     */     //   #430	-> 128
/*     */     //   #431	-> 133
/*     */     //   #430	-> 137
/*     */     //   #432	-> 139
/*     */     //   #433	-> 149
/*     */     //   #434	-> 176
/*     */     //   #435	-> 193
/*     */     //   #219	-> 196
/*     */     //   #435	-> 204
/*     */     //   #436	-> 205
/*     */     //   #439	-> 209
/*     */     //   #220	-> 210
/*     */     // Local variable table:
/*     */     //   start	length	slot	name	descriptor
/*     */     //   47	9	8	$i$a$-tryCoerceValue-StreamingJsonDecoder$coerceInputValue$1	I
/*     */     //   44	12	7	it	Z
/*     */     //   95	9	8	$i$a$-tryCoerceValue-StreamingJsonDecoder$coerceInputValue$1	I
/*     */     //   92	12	7	it	Z
/*     */     //   114	14	7	$i$a$-tryCoerceValue-StreamingJsonDecoder$coerceInputValue$2	I
/*     */     //   196	8	10	$i$a$-tryCoerceValue-StreamingJsonDecoder$coerceInputValue$3	I
/*     */     //   139	70	9	enumValue$iv	Ljava/lang/String;
/*     */     //   149	60	7	enumIndex$iv	I
/*     */     //   176	33	8	coerceToNull$iv	Z
/*     */     //   8	202	4	$i$f$tryCoerceValue	I
/*     */     //   17	193	5	isOptional$iv	Z
/*     */     //   26	184	6	elementDescriptor$iv	Lkotlinx/serialization/descriptors/SerialDescriptor;
/*     */     //   5	205	3	$this$tryCoerceValue$iv	Lkotlinx/serialization/json/Json;
/*     */     //   0	211	0	this	Lkotlinx/serialization/json/internal/StreamingJsonDecoder;
/*     */     //   0	211	1	descriptor	Lkotlinx/serialization/descriptors/SerialDescriptor;
/*     */     //   0	211	2	index	I }
/*     */   private final int decodeObjectIndex(SerialDescriptor descriptor) { boolean hasComma = this.lexer.tryConsumeComma(); while (this.lexer.canConsumeValue()) { hasComma = false; String key = decodeStringKey(); this.lexer.consumeNextToken(':'); int index = JsonNamesMapKt.getJsonNameIndex(descriptor, this.json, key); if (index != -3) { if (this.configuration.getCoerceInputValues() && coerceInputValue(descriptor, index)) { hasComma = this.lexer.tryConsumeComma(); } else { if (this.elementMarker != null) { this.elementMarker.mark$kotlinx_serialization_json(index); } else {  }  return index; }  } else {  }
/*     */        boolean isUnknown = true; if (isUnknown)
/*     */         hasComma = handleUnknown(descriptor, key);  }
/*     */      if (hasComma && !this.json.getConfiguration().getAllowTrailingComma()) { JsonExceptionsKt.invalidTrailingComma$default(this.lexer, null, 1, null); throw new KotlinNothingValueException(); }
/*     */      return (this.elementMarker != null) ? this.elementMarker.nextUnmarkedIndex$kotlinx_serialization_json() : -1; }
/*     */   private final boolean handleUnknown(SerialDescriptor descriptor, String key) { if (JsonNamesMapKt.ignoreUnknownKeys(descriptor, this.json) || trySkip(this.discriminatorHolder, key)) { this.lexer.skipElement(this.configuration.isLenient()); }
/*     */     else { this.lexer.path.popDescriptor(); this.lexer.failOnUnknownKey(key); }
/*     */      return this.lexer.tryConsumeComma(); }
/*     */   private final int decodeListIndex() { boolean hasComma = this.lexer.tryConsumeComma(); if (this.currentIndex != -1 && !hasComma) { AbstractJsonLexer.fail$default(this.lexer, "Expected end of the array or comma", 0, null, 6, null); throw new KotlinNothingValueException(); }
/*     */      this.currentIndex++; if (hasComma && !this.json.getConfiguration().getAllowTrailingComma()) { JsonExceptionsKt.invalidTrailingComma(this.lexer, "array"); throw new KotlinNothingValueException(); }
/*     */      return this.lexer.canConsumeValue() ? this.currentIndex : -1; }
/*     */   public boolean decodeBoolean() { return this.lexer.consumeBooleanLenient(); }
/*     */   public byte decodeByte() { long value = this.lexer.consumeNumericLiteral(); if (value != (byte)(int)value) { AbstractJsonLexer.fail$default(this.lexer, "Failed to parse byte for input '" + value + '\'', 0, null, 6, null); throw new KotlinNothingValueException(); }
/*     */      return (byte)(int)value; }
/*     */   public short decodeShort() { long value = this.lexer.consumeNumericLiteral(); if (value != (short)(int)value) { AbstractJsonLexer.fail$default(this.lexer, "Failed to parse short for input '" + value + '\'', 0, null, 6, null); throw new KotlinNothingValueException(); }
/*     */      return (short)(int)value; }
/*     */   public int decodeInt() { long value = this.lexer.consumeNumericLiteral(); if (value != (int)value) { AbstractJsonLexer.fail$default(this.lexer, "Failed to parse int for input '" + value + '\'', 0, null, 6, null); throw new KotlinNothingValueException(); }
/*     */      return (int)value; }
/*     */   public long decodeLong() { return this.lexer.consumeNumericLiteral(); }
/* 440 */   public float decodeFloat() { AbstractJsonLexer abstractJsonLexer = this.lexer; String expectedType$iv = "float"; int $i$f$parseString = 0; String input$iv = abstractJsonLexer.consumeStringLenient();
/*     */     
/* 442 */     try { String $this$decodeFloat_u24lambda_u246 = input$iv; int $i$a$-parseString-StreamingJsonDecoder$decodeFloat$result$1 = 0; }
/* 443 */     catch (IllegalArgumentException e$iv)
/* 444 */     { AbstractJsonLexer.fail$default(abstractJsonLexer, "Failed to parse type '" + expectedType$iv + "' for input '" + input$iv + '\'', 0, null, 6, null); throw new KotlinNothingValueException(); }  float result = Float.parseFloat($this$decodeFloat_u24lambda_u246); boolean specialFp = this.json.getConfiguration().getAllowSpecialFloatingPointValues(); if (!specialFp) { float f = result; if (!((!Float.isInfinite(f) && !Float.isNaN(f)) ? 1 : 0)) { JsonExceptionsKt.throwInvalidFloatingPointDecoded(this.lexer, Float.valueOf(result)); throw new KotlinNothingValueException(); }  }
/* 445 */      return result; } public double decodeDouble() { AbstractJsonLexer abstractJsonLexer = this.lexer; String expectedType$iv = "double"; int $i$f$parseString = 0; String input$iv = abstractJsonLexer.consumeStringLenient();
/*     */     try {
/* 447 */       String $this$decodeDouble_u24lambda_u247 = input$iv; int $i$a$-parseString-StreamingJsonDecoder$decodeDouble$result$1 = 0;
/* 448 */     } catch (IllegalArgumentException e$iv) {
/* 449 */       AbstractJsonLexer.fail$default(abstractJsonLexer, "Failed to parse type '" + expectedType$iv + "' for input '" + input$iv + '\'', 0, null, 6, null); throw new KotlinNothingValueException();
/*     */     } 
/*     */     double result = Double.parseDouble($this$decodeDouble_u24lambda_u247);
/*     */     boolean specialFp = this.json.getConfiguration().getAllowSpecialFloatingPointValues();
/*     */     if (!specialFp) {
/*     */       double d = result;
/*     */       if (!((!Double.isInfinite(d) && !Double.isNaN(d)) ? 1 : 0)) {
/*     */         JsonExceptionsKt.throwInvalidFloatingPointDecoded(this.lexer, Double.valueOf(result));
/*     */         throw new KotlinNothingValueException();
/*     */       } 
/*     */     } 
/*     */     return result; }
/*     */ 
/*     */   
/*     */   public char decodeChar() {
/*     */     String string = this.lexer.consumeStringLenient();
/*     */     if (string.length() != 1) {
/*     */       AbstractJsonLexer.fail$default(this.lexer, "Expected single char, but got '" + string + '\'', 0, null, 6, null);
/*     */       throw new KotlinNothingValueException();
/*     */     } 
/*     */     return string.charAt(0);
/*     */   }
/*     */   
/*     */   private final String decodeStringKey() {
/*     */     return this.configuration.isLenient() ? this.lexer.consumeStringLenientNotNull() : this.lexer.consumeKeyString();
/*     */   }
/*     */   
/*     */   @NotNull
/*     */   public String decodeString() {
/*     */     return this.configuration.isLenient() ? this.lexer.consumeStringLenientNotNull() : this.lexer.consumeString();
/*     */   }
/*     */   
/*     */   public void decodeStringChunked(@NotNull Function1<? super String, Unit> consumeChunk) {
/*     */     Intrinsics.checkNotNullParameter(consumeChunk, "consumeChunk");
/*     */     this.lexer.consumeStringChunked(this.configuration.isLenient(), consumeChunk);
/*     */   }
/*     */   
/*     */   @NotNull
/*     */   public Decoder decodeInline(@NotNull SerialDescriptor descriptor) {
/*     */     Intrinsics.checkNotNullParameter(descriptor, "descriptor");
/*     */     return StreamingJsonEncoderKt.isUnsignedNumber(descriptor) ? (Decoder)new JsonDecoderForUnsignedTypes(this.lexer, this.json) : super.decodeInline(descriptor);
/*     */   }
/*     */   
/*     */   public int decodeEnum(@NotNull SerialDescriptor enumDescriptor) {
/*     */     Intrinsics.checkNotNullParameter(enumDescriptor, "enumDescriptor");
/*     */     return JsonNamesMapKt.getJsonNameIndexOrThrow(enumDescriptor, this.json, decodeString(), " at path " + this.lexer.path.getPath());
/*     */   } }


/* Location:              C:\Users\yuzum\Downloads\ej-release-243.132.63.zip!\ej\lib\kotlinx-serialization-json-jvm-1.8.0.jar!\kotlinx\serialization\json\internal\StreamingJsonDecoder.class
 * Java compiler version: 8 (52.0)
 * JD-Core Version:       1.1.3
 */